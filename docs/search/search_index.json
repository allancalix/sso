{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Warning: The author of this application is not a security expert. The code has not undergone any kind of review. Use it at your own risk! sso-grpc is a gRPC authentication server, with an OpenAPI version 2 proxy server sso-openapi . It is designed for use as a backend for other applications which must authenticate users and their requests, such as API servers. sso (GitHub) sso (crates.io) OpenAPI v2 specification (sso.swagger.json) The following diagram is an overview of the authentication system. sso-grpc authentication server. Providers are registered as a Service with sso-grpc, for example API servers. A Service Key is used to authenticate requests from the service to sso-grpc. Consumers are registered as a User with sso-grpc. A User Key is used to authenticate a user, and authenticate requests from the user to the service. In the diagram above, Service A can authenticate requests from User 1 and User 2 . Service B can authenticate requests from User 2 and User 3 . The following diagram shows how services and sso-grpc integrate to authenticate user requests. User with token or key acquired by authentication method sends HTTP request to service. Service sends HTTP request to sso with its own service key, and the users token or key. sso authenticates service using the service key, and verifies user token or key. If authenticated/verified, service handles request and sends HTTP response to user. User handles HTTP response. Features User Authentication User authentication methods are organised into Provider groups. Services are registered with callback URLs for each supported provider. Local Provider User authentication using unique email address and password. User login returns access and refresh tokens. User registration with email confirmation. User password reset via email. User password update required. User email address and password updates require current password. Outgoing emails contain revokation links to disable user access in case of compromised access. Password stored as argon2 hash using libreauth . Password strength checked by zxcvbn . Password leaks checked by Pwned Passwords . Password not set disables password login. User key for service of Token type is required. GitHub Provider User authentication using GitHub OAuth2 . User login returns access and refresh tokens. User key for service of Token type is required. Microsoft Provider User authentication using Microsoft OAuth2 . User login returns access and refresh tokens. User key for service of Token type is required. Request Authentication Request authentication methods. Services use these endpoints to determine whether a user request is permitted. Key Request authentication using an API key distributed by the service. User authenticates requests to a service using a unique, random key. User key can be revoked, but is not time-limited. User key for service of Key type is required. Token Request authentication using access token returned by user authentication provider. User authenticates requests to a service using a JWT access token. User generates new access and refresh tokens using a JWT refresh token. User token is time-limited. User key can be revoked, which also revokes all tokens the key produced. User key for service of Token type is required. TOTP Request authentication using TOTP code generated from a key distributed by the service. User key for service of Totp type is required. CSRF Tokens Services can use sso-grpc to create and verify single-use CSRF tokens If service uses cookies for authentication, these tokens are used in form templates to prevent CSRF attacks. Audit Logging All sso-grpc endpoint failures after input validation are audited. POST , PATCH , DELETE endpoint successes are also audited. Services are able to read, create and update their own audit logs. Audit logs are append only, logs can be created when requests are received and response data can be added when request handled. Audit logs have retention time (default 3 months).","title":"Introduction"},{"location":"#introduction","text":"Warning: The author of this application is not a security expert. The code has not undergone any kind of review. Use it at your own risk! sso-grpc is a gRPC authentication server, with an OpenAPI version 2 proxy server sso-openapi . It is designed for use as a backend for other applications which must authenticate users and their requests, such as API servers. sso (GitHub) sso (crates.io) OpenAPI v2 specification (sso.swagger.json) The following diagram is an overview of the authentication system. sso-grpc authentication server. Providers are registered as a Service with sso-grpc, for example API servers. A Service Key is used to authenticate requests from the service to sso-grpc. Consumers are registered as a User with sso-grpc. A User Key is used to authenticate a user, and authenticate requests from the user to the service. In the diagram above, Service A can authenticate requests from User 1 and User 2 . Service B can authenticate requests from User 2 and User 3 . The following diagram shows how services and sso-grpc integrate to authenticate user requests. User with token or key acquired by authentication method sends HTTP request to service. Service sends HTTP request to sso with its own service key, and the users token or key. sso authenticates service using the service key, and verifies user token or key. If authenticated/verified, service handles request and sends HTTP response to user. User handles HTTP response.","title":"Introduction"},{"location":"#features","text":"","title":"Features"},{"location":"#user-authentication","text":"User authentication methods are organised into Provider groups. Services are registered with callback URLs for each supported provider.","title":"User Authentication"},{"location":"#local-provider","text":"User authentication using unique email address and password. User login returns access and refresh tokens. User registration with email confirmation. User password reset via email. User password update required. User email address and password updates require current password. Outgoing emails contain revokation links to disable user access in case of compromised access. Password stored as argon2 hash using libreauth . Password strength checked by zxcvbn . Password leaks checked by Pwned Passwords . Password not set disables password login. User key for service of Token type is required.","title":"Local Provider"},{"location":"#github-provider","text":"User authentication using GitHub OAuth2 . User login returns access and refresh tokens. User key for service of Token type is required.","title":"GitHub Provider"},{"location":"#microsoft-provider","text":"User authentication using Microsoft OAuth2 . User login returns access and refresh tokens. User key for service of Token type is required.","title":"Microsoft Provider"},{"location":"#request-authentication","text":"Request authentication methods. Services use these endpoints to determine whether a user request is permitted.","title":"Request Authentication"},{"location":"#key","text":"Request authentication using an API key distributed by the service. User authenticates requests to a service using a unique, random key. User key can be revoked, but is not time-limited. User key for service of Key type is required.","title":"Key"},{"location":"#token","text":"Request authentication using access token returned by user authentication provider. User authenticates requests to a service using a JWT access token. User generates new access and refresh tokens using a JWT refresh token. User token is time-limited. User key can be revoked, which also revokes all tokens the key produced. User key for service of Token type is required.","title":"Token"},{"location":"#totp","text":"Request authentication using TOTP code generated from a key distributed by the service. User key for service of Totp type is required.","title":"TOTP"},{"location":"#csrf-tokens","text":"Services can use sso-grpc to create and verify single-use CSRF tokens If service uses cookies for authentication, these tokens are used in form templates to prevent CSRF attacks.","title":"CSRF Tokens"},{"location":"#audit-logging","text":"All sso-grpc endpoint failures after input validation are audited. POST , PATCH , DELETE endpoint successes are also audited. Services are able to read, create and update their own audit logs. Audit logs are append only, logs can be created when requests are received and response data can be added when request handled. Audit logs have retention time (default 3 months).","title":"Audit Logging"},{"location":"changelog/0.1.0/","text":"0.1.0 (2019-05-16) Added First version.","title":"0.1.0 (2019-05-16)"},{"location":"changelog/0.1.0/#010-2019-05-16","text":"","title":"0.1.0 (2019-05-16)"},{"location":"changelog/0.1.0/#added","text":"First version.","title":"Added"},{"location":"changelog/0.10.0/","text":"0.10.0 (2020-03-12) Added Added server and client TLS support. Added built-in CORS support to sso-openapi , configurable via SSO_CORS_ALLOW_ORIGIN environment variable. Added optional Traefik forward authentication integration. Added grpc_service module to make service implementation easier. Changed Updated crate dependencies. Logging now defaults to single line JSON objects. Replaced user_id field with email field for user update email and password endpoints. Manual updates. Services can use list services endpoint to list only themselves. Refactoring for improved library interface. Fixed Replaced tokio_executor::blocking with tokio::task::spawn_blocking , reduces maximum memory use from ~800MB to ~200MB for repeated integration tests. Fixed revoke endpoints only disabled user, did not also disable and revoke keys. Fixed update password endpoint password meta is for current password. Fixed text validator rejects empty strings. Fixed updating user password via update or reset password endpoints did not set password_require_update to false.","title":"0.10.0 (2020-03-12)"},{"location":"changelog/0.10.0/#0100-2020-03-12","text":"","title":"0.10.0 (2020-03-12)"},{"location":"changelog/0.10.0/#added","text":"Added server and client TLS support. Added built-in CORS support to sso-openapi , configurable via SSO_CORS_ALLOW_ORIGIN environment variable. Added optional Traefik forward authentication integration. Added grpc_service module to make service implementation easier.","title":"Added"},{"location":"changelog/0.10.0/#changed","text":"Updated crate dependencies. Logging now defaults to single line JSON objects. Replaced user_id field with email field for user update email and password endpoints. Manual updates. Services can use list services endpoint to list only themselves. Refactoring for improved library interface.","title":"Changed"},{"location":"changelog/0.10.0/#fixed","text":"Replaced tokio_executor::blocking with tokio::task::spawn_blocking , reduces maximum memory use from ~800MB to ~200MB for repeated integration tests. Fixed revoke endpoints only disabled user, did not also disable and revoke keys. Fixed update password endpoint password meta is for current password. Fixed text validator rejects empty strings. Fixed updating user password via update or reset password endpoints did not set password_require_update to false.","title":"Fixed"},{"location":"changelog/0.11.0/","text":"0.11.0 (?)","title":"0.11.0 (?)"},{"location":"changelog/0.11.0/#0110","text":"","title":"0.11.0 (?)"},{"location":"changelog/0.2.0/","text":"0.2.0 (2019-07-07) Added Added audit logging to authentication routes. Added is enabled flag to services, users and keys, added is revoked flag to keys. Added synchronous and asynchronous clients to library. Added email_eq query option to user list route. Added local provider update user email, password routes. Added type parameter to service URL callback queries. Changed Changed database schema to use strings as IDs. Changed list route endpoints to return data ID arrays. Changed CSRF key, value pairs to use TTL in seconds. Changed token type handling, user token split into access and refresh tokens. Moved OAuth2 routes into provider groups. Moved login, reset routes into local provider group. Upgraded to version 3 of oauth2 library. Removed skeptic from tests, use Cargo test runner. Moved route types to public api module. Fixed Fixed not validating service URLs before save using URL parse, improved URL error handling. Fixed inconsistent core error display strings. Fixed duplicate user email address returned internal server error code. Fixed Lettre email error type handling.","title":"0.2.0 (2019-07-07)"},{"location":"changelog/0.2.0/#020-2019-07-07","text":"","title":"0.2.0 (2019-07-07)"},{"location":"changelog/0.2.0/#added","text":"Added audit logging to authentication routes. Added is enabled flag to services, users and keys, added is revoked flag to keys. Added synchronous and asynchronous clients to library. Added email_eq query option to user list route. Added local provider update user email, password routes. Added type parameter to service URL callback queries.","title":"Added"},{"location":"changelog/0.2.0/#changed","text":"Changed database schema to use strings as IDs. Changed list route endpoints to return data ID arrays. Changed CSRF key, value pairs to use TTL in seconds. Changed token type handling, user token split into access and refresh tokens. Moved OAuth2 routes into provider groups. Moved login, reset routes into local provider group. Upgraded to version 3 of oauth2 library. Removed skeptic from tests, use Cargo test runner. Moved route types to public api module.","title":"Changed"},{"location":"changelog/0.2.0/#fixed","text":"Fixed not validating service URLs before save using URL parse, improved URL error handling. Fixed inconsistent core error display strings. Fixed duplicate user email address returned internal server error code. Fixed Lettre email error type handling.","title":"Fixed"},{"location":"changelog/0.3.0/","text":"0.3.0 (2019-08-03) Added Improved email templates, removed template parameters from routes. Defined server routes and other constants in server::api module. Finished synchronous and asynchronous clients. Added support for audit list query cases gt AND lt , created_gte AND created_lte . Added /v1/metrics endpoint for Prometheus integration. Added support for optional audit logs to some authentication endpoints. Added TLS configuration support to server and clients. Added hostname configuration to server. Changed Changed audit list query parameters when using created_gte or created_lte options, added optional offset_id parameter to exclude previous results. Moved email handling from server::smtp module to notify module. Moved main.rs:Error into cli module, refactored error handling. Use Forwarded header instead of X-Forwarded-For for audit logs. Renamed local authentication provider reset, update routes. Improved configuration interfaces using derive_builder crate. Fixed Reset password route now returns OK in cases where user email address does not exist. Fixed audit log errors were created for root key authentication when authenticating a service key. Fixed internal server errors returned to client when OAuth2 provider is disabled.","title":"0.3.0 (2019-08-03)"},{"location":"changelog/0.3.0/#030-2019-08-03","text":"","title":"0.3.0 (2019-08-03)"},{"location":"changelog/0.3.0/#added","text":"Improved email templates, removed template parameters from routes. Defined server routes and other constants in server::api module. Finished synchronous and asynchronous clients. Added support for audit list query cases gt AND lt , created_gte AND created_lte . Added /v1/metrics endpoint for Prometheus integration. Added support for optional audit logs to some authentication endpoints. Added TLS configuration support to server and clients. Added hostname configuration to server.","title":"Added"},{"location":"changelog/0.3.0/#changed","text":"Changed audit list query parameters when using created_gte or created_lte options, added optional offset_id parameter to exclude previous results. Moved email handling from server::smtp module to notify module. Moved main.rs:Error into cli module, refactored error handling. Use Forwarded header instead of X-Forwarded-For for audit logs. Renamed local authentication provider reset, update routes. Improved configuration interfaces using derive_builder crate.","title":"Changed"},{"location":"changelog/0.3.0/#fixed","text":"Reset password route now returns OK in cases where user email address does not exist. Fixed audit log errors were created for root key authentication when authenticating a service key. Fixed internal server errors returned to client when OAuth2 provider is disabled.","title":"Fixed"},{"location":"changelog/0.4.0/","text":"0.4.0 (2019-09-09) Added Added some process metrics to Prometheus integration. Created asynchronous client actor to handle outgoing HTTP requests. Added environment variable PASSWORD_PWNED_ENABLED to enable pwned passwords integration. Changed Replaced bcrypt with libreauth crate for password hashing. Use libreauth key generation for CSRF keys and Key values. Improved modules public interfaces. Changed driver interface to use Uuid types instead of strings. Renamed configuration structures to options to improve consistency. Fixed Fixed missing dyn keyword warnings.","title":"0.4.0 (2019-09-09)"},{"location":"changelog/0.4.0/#040-2019-09-09","text":"","title":"0.4.0 (2019-09-09)"},{"location":"changelog/0.4.0/#added","text":"Added some process metrics to Prometheus integration. Created asynchronous client actor to handle outgoing HTTP requests. Added environment variable PASSWORD_PWNED_ENABLED to enable pwned passwords integration.","title":"Added"},{"location":"changelog/0.4.0/#changed","text":"Replaced bcrypt with libreauth crate for password hashing. Use libreauth key generation for CSRF keys and Key values. Improved modules public interfaces. Changed driver interface to use Uuid types instead of strings. Renamed configuration structures to options to improve consistency.","title":"Changed"},{"location":"changelog/0.4.0/#fixed","text":"Fixed missing dyn keyword warnings.","title":"Fixed"},{"location":"changelog/0.5.0/","text":"0.5.0 (2019-10-05) Added Added TOTP validation route. Added key flags: allow_key , allow_token , allow_totp . Added user fields: locale , timezone . Changed Renamed project sso , ark was taken by various products and crates. Code consistency improvements. Renamed audit path to type string. Replaced serde_urlencoded with serde_qs for more advanced query string support. Improved audit metric collection efficiency. Changed authentication provider interface so callbacks always go to service.","title":"0.5.0 (2019-10-05)"},{"location":"changelog/0.5.0/#050-2019-10-05","text":"","title":"0.5.0 (2019-10-05)"},{"location":"changelog/0.5.0/#added","text":"Added TOTP validation route. Added key flags: allow_key , allow_token , allow_totp . Added user fields: locale , timezone .","title":"Added"},{"location":"changelog/0.5.0/#changed","text":"Renamed project sso , ark was taken by various products and crates. Code consistency improvements. Renamed audit path to type string. Replaced serde_urlencoded with serde_qs for more advanced query string support. Improved audit metric collection efficiency. Changed authentication provider interface so callbacks always go to service.","title":"Changed"},{"location":"changelog/0.6.0/","text":"0.6.0 (2019-10-07) Changed Replaced key flags with type: Key , Token or Totp . Added user flags: password_allow_reset and password_require_update . Return Unauthorised instead of Forbidden for missing authentication. User update email and password endpoints accept user_id instead of key or token . Fixed Fixed read user by ID route /v1/user/{id} attempts to read key.","title":"0.6.0 (2019-10-07)"},{"location":"changelog/0.6.0/#060-2019-10-07","text":"","title":"0.6.0 (2019-10-07)"},{"location":"changelog/0.6.0/#changed","text":"Replaced key flags with type: Key , Token or Totp . Added user flags: password_allow_reset and password_require_update . Return Unauthorised instead of Forbidden for missing authentication. User update email and password endpoints accept user_id instead of key or token .","title":"Changed"},{"location":"changelog/0.6.0/#fixed","text":"Fixed read user by ID route /v1/user/{id} attempts to read key.","title":"Fixed"},{"location":"changelog/0.7.0/","text":"0.7.0 (2019-10-19) Added Added Debug trait implementations for public types. Added filters to key list endpoint with KeyFilter options. Added filters to service list endpoint with ServiceFilter options. Added id query parameter array for key, service and user list endpoint filtering. Added docker-pg-dump , docker-pg-restore targets to Makefile.toml . Added CSRF create and verify API endpoints. Added PATCH audit log endpoint for appending data to audit logs. Subject may be left null when audit log created and added later (existing data may not be overwritten). Added optional subject column to audit log table, added support for filtering. Use TimescaleDB hypertable for audit log table. Changed Changed table column names to remove prefixes for DriverPostgres . Key value is only returned via created endpoint. Include user data in token and key responses so user read is unnecessary. Return audit log on endpoints which accept optional audit properties. Audit logging improvements, more endpoints now create audit logs for success/failure, diff data is generated for key, service and user updates. Added prefix Sso to internal audit log types. Refactoring, move api module to crate root. Fixed Fixed clippy too many arguments warnings. Fixed ClientActor GET request ignores query string. Fixed 500 status code returned trying to create key with invalid service or user ID.","title":"0.7.0 (2019-10-19)"},{"location":"changelog/0.7.0/#070-2019-10-19","text":"","title":"0.7.0 (2019-10-19)"},{"location":"changelog/0.7.0/#added","text":"Added Debug trait implementations for public types. Added filters to key list endpoint with KeyFilter options. Added filters to service list endpoint with ServiceFilter options. Added id query parameter array for key, service and user list endpoint filtering. Added docker-pg-dump , docker-pg-restore targets to Makefile.toml . Added CSRF create and verify API endpoints. Added PATCH audit log endpoint for appending data to audit logs. Subject may be left null when audit log created and added later (existing data may not be overwritten). Added optional subject column to audit log table, added support for filtering. Use TimescaleDB hypertable for audit log table.","title":"Added"},{"location":"changelog/0.7.0/#changed","text":"Changed table column names to remove prefixes for DriverPostgres . Key value is only returned via created endpoint. Include user data in token and key responses so user read is unnecessary. Return audit log on endpoints which accept optional audit properties. Audit logging improvements, more endpoints now create audit logs for success/failure, diff data is generated for key, service and user updates. Added prefix Sso to internal audit log types. Refactoring, move api module to crate root.","title":"Changed"},{"location":"changelog/0.7.0/#fixed","text":"Fixed clippy too many arguments warnings. Fixed ClientActor GET request ignores query string. Fixed 500 status code returned trying to create key with invalid service or user ID.","title":"Fixed"},{"location":"changelog/0.8.0/","text":"0.8.0 (2019-11-03) Added Added name_ge , name_le , offset_id query parameters to user list route for sorting by name. Added status_code to audit logs. Endpoints which accepted custom audit objects now accept custom audit type string. Status code, subject and data can be added later via update endpoint. Added User-Authorization header handling, value is user key or token. Service may include this header to add user and key information in created audit logs. Added optional user_id query parameter to key read endpoint to mask by user ID. Added user_allow_register and user_email_text columns to services, used to allow user registration endpoint functionality and append text to outgoing emails for services. Changed Removed TimescaleDB hypertable for audit log, don't make use of any features. Finish removing core module by refactoring code in api and driver modules. Removed SsoError and SsoResult in favour of driver types. Changed internal audit log type format, use : character to separate applications. Include status code in prometheus audit log counter metrics, defaults to 0 if NULL. Add compare_vec function to AuditDiffBuilder. Removed NotifyActor , moved templating into driver module and SMTP client into server module. Removed ClientActor , refactored sync and async clients to be more consistent. Fixed Fixed list tests can fail because concurrent tests create rows within order being tested. Fixed zxcvbn warning caused by passing empty strings, also stops passing empty strings to pwned passwords API. Fixed key_id not set on audit log when authenticating service keys. Fixed process metrics add to previous value, use gauges instead of counters. Fixed impl_enum_to_from_string use statements to not conflict with library types.","title":"0.8.0 (2019-11-03)"},{"location":"changelog/0.8.0/#080-2019-11-03","text":"","title":"0.8.0 (2019-11-03)"},{"location":"changelog/0.8.0/#added","text":"Added name_ge , name_le , offset_id query parameters to user list route for sorting by name. Added status_code to audit logs. Endpoints which accepted custom audit objects now accept custom audit type string. Status code, subject and data can be added later via update endpoint. Added User-Authorization header handling, value is user key or token. Service may include this header to add user and key information in created audit logs. Added optional user_id query parameter to key read endpoint to mask by user ID. Added user_allow_register and user_email_text columns to services, used to allow user registration endpoint functionality and append text to outgoing emails for services.","title":"Added"},{"location":"changelog/0.8.0/#changed","text":"Removed TimescaleDB hypertable for audit log, don't make use of any features. Finish removing core module by refactoring code in api and driver modules. Removed SsoError and SsoResult in favour of driver types. Changed internal audit log type format, use : character to separate applications. Include status code in prometheus audit log counter metrics, defaults to 0 if NULL. Add compare_vec function to AuditDiffBuilder. Removed NotifyActor , moved templating into driver module and SMTP client into server module. Removed ClientActor , refactored sync and async clients to be more consistent.","title":"Changed"},{"location":"changelog/0.8.0/#fixed","text":"Fixed list tests can fail because concurrent tests create rows within order being tested. Fixed zxcvbn warning caused by passing empty strings, also stops passing empty strings to pwned passwords API. Fixed key_id not set on audit log when authenticating service keys. Fixed process metrics add to previous value, use gauges instead of counters. Fixed impl_enum_to_from_string use statements to not conflict with library types.","title":"Fixed"},{"location":"changelog/0.9.0/","text":"0.9.0 (2020-01-19) Breaking Rewrite to use tonic gRPC server instead of actix-web HTTP server. Added Added compare_opt function to AuditDiffBuilder. Added optional subject query parameter to audit read endpoint to mask by subject. Added scheduled tasks for audit log retention support. Added auth/provider/local/register/revoke , auth/provider/local/reset-password/revoke endpoints. Removed Removed sysinfo dependency, use process feature of prometheus crate for process metrics. Removed job_scheduler dependency, moved retention task to cli.","title":"0.9.0 (2020-01-19)"},{"location":"changelog/0.9.0/#090-2020-01-19","text":"","title":"0.9.0 (2020-01-19)"},{"location":"changelog/0.9.0/#breaking","text":"Rewrite to use tonic gRPC server instead of actix-web HTTP server.","title":"Breaking"},{"location":"changelog/0.9.0/#added","text":"Added compare_opt function to AuditDiffBuilder. Added optional subject query parameter to audit read endpoint to mask by subject. Added scheduled tasks for audit log retention support. Added auth/provider/local/register/revoke , auth/provider/local/reset-password/revoke endpoints.","title":"Added"},{"location":"changelog/0.9.0/#removed","text":"Removed sysinfo dependency, use process feature of prometheus crate for process metrics. Removed job_scheduler dependency, moved retention task to cli.","title":"Removed"},{"location":"developer/design/","text":"Design Dependencies Crate dependencies for cryptography, authentication. libreauth jsonwebtoken oauth2-rs OWASP: ASVS OWASP ASVS The OWASP Application Security Verification Standard is being used as a reference to improve this application. These are some development and design notes based on requirements from the 4.0 version of the ASVS standard. This is a self-evaluation and should be viewed skeptically. 1.2.1 Binaries must be run as unique or special low privilege operating system accounts. 1.2.2 HTTP calls (except ping) require service key authentication. 1.2.3 Server is designed to provide multiple authentication mechanisms, none of which have been vetted. Relies on libraries which may be unvetted, e.g. libreauth, jsonwebtoken, rustls, etc. What does strong authentication mean in this context? One feature is providing email/password login, which is probably not considered strong authentication. Audit logging and monitoring via prometheus. 1.2.4 All authentication pathways are designed to be as strong as that pathway can be. For example, email password resets are supported which are probably not considered strong. 1.4.1 All access controls are enforced at a trusted enforcement point (the server). Registered services must implement their own access controls for their own data. 1.4.2 Access controls are designed for many services and many users, where users have access to one or more services. All registered services can read all registered users, other services and keys belonging to them are hidden. Registered services may implement more complex access controls for their own data. 1.4.3 Verify enforcement of principle of least privelege, requires more integration tests. 1.4.4 HTTP calls (except ping) require service key authentication. 1.4.5 This crate provides user authentication, not access control, is this out of scope? 1.5.1 Terms of service columns and user accepted columns, handle changes to terms. 1.5.2 API is JSON requests over HTTP so serialisation is required. Using [serde][serde] for serialisation and deserialisation. 1.5.3 Input validation is enforced at a trusted enforcement point (the server). Using [validator][validator] for input validation. 1.5.4 All output encoding is [UTF-8][utf-8]. 1.6.1 Key values are used for [JWT][jwt] cryptographic encoding and decoding. Key values are only returned to service or user on creation. Keys can be disabled and/or revoked to prevent use. 1.6.2 Cannot verify that services protect created key values. 1.6.3 No hard-coded keys or passwords, all keys and passwords can be replaced. 1.6.4 API key support is clear-text equivalent. Authentication via API key is probably not considered low risk secret. Keys can be disabled/revoked to mitigate breaches, but this is not a solution. 1.7.1, 1.7.2 Audit log format is common and used when making calls via API. Stdout/stderr logging is not consistent. Audit logs are saved to table, not transmitted to a remote system. Stdout/stderr logging is not transmitted to a remote system, 1.8.1, 1.8.2 Sensitive data is not identified or classified into protection levels. 1.9.1, 1.9.2 Connection to database, other services must be encrypted. 1.10.1 Git and GitHub used for source code control, no formal commit procedure. 1.11.1 Little documentation and definitions of application components, out of date. 1.11.2, 1.11.3 No unsynchronised state shared between high-value business logic flows. All code should be threadsafe (no use of unsafe). I don't think there is any but probably needs more thorough check, including dependencies. 1.12.1, 1.12.2 No user uploaded files, if feature added in future files will be stored as binary blobs in database. Serve files as octet stream downloads if added.","title":"Design"},{"location":"developer/design/#design","text":"","title":"Design"},{"location":"developer/design/#dependencies","text":"Crate dependencies for cryptography, authentication. libreauth jsonwebtoken oauth2-rs","title":"Dependencies"},{"location":"developer/design/#owasp-asvs","text":"OWASP ASVS The OWASP Application Security Verification Standard is being used as a reference to improve this application. These are some development and design notes based on requirements from the 4.0 version of the ASVS standard. This is a self-evaluation and should be viewed skeptically.","title":"OWASP: ASVS"},{"location":"developer/design/#121","text":"Binaries must be run as unique or special low privilege operating system accounts.","title":"1.2.1"},{"location":"developer/design/#122","text":"HTTP calls (except ping) require service key authentication.","title":"1.2.2"},{"location":"developer/design/#123","text":"Server is designed to provide multiple authentication mechanisms, none of which have been vetted. Relies on libraries which may be unvetted, e.g. libreauth, jsonwebtoken, rustls, etc. What does strong authentication mean in this context? One feature is providing email/password login, which is probably not considered strong authentication. Audit logging and monitoring via prometheus.","title":"1.2.3"},{"location":"developer/design/#124","text":"All authentication pathways are designed to be as strong as that pathway can be. For example, email password resets are supported which are probably not considered strong.","title":"1.2.4"},{"location":"developer/design/#141","text":"All access controls are enforced at a trusted enforcement point (the server). Registered services must implement their own access controls for their own data.","title":"1.4.1"},{"location":"developer/design/#142","text":"Access controls are designed for many services and many users, where users have access to one or more services. All registered services can read all registered users, other services and keys belonging to them are hidden. Registered services may implement more complex access controls for their own data.","title":"1.4.2"},{"location":"developer/design/#143","text":"Verify enforcement of principle of least privelege, requires more integration tests.","title":"1.4.3"},{"location":"developer/design/#144","text":"HTTP calls (except ping) require service key authentication.","title":"1.4.4"},{"location":"developer/design/#145","text":"This crate provides user authentication, not access control, is this out of scope?","title":"1.4.5"},{"location":"developer/design/#151","text":"Terms of service columns and user accepted columns, handle changes to terms.","title":"1.5.1"},{"location":"developer/design/#152","text":"API is JSON requests over HTTP so serialisation is required. Using [serde][serde] for serialisation and deserialisation.","title":"1.5.2"},{"location":"developer/design/#153","text":"Input validation is enforced at a trusted enforcement point (the server). Using [validator][validator] for input validation.","title":"1.5.3"},{"location":"developer/design/#154","text":"All output encoding is [UTF-8][utf-8].","title":"1.5.4"},{"location":"developer/design/#161","text":"Key values are used for [JWT][jwt] cryptographic encoding and decoding. Key values are only returned to service or user on creation. Keys can be disabled and/or revoked to prevent use.","title":"1.6.1"},{"location":"developer/design/#162","text":"Cannot verify that services protect created key values.","title":"1.6.2"},{"location":"developer/design/#163","text":"No hard-coded keys or passwords, all keys and passwords can be replaced.","title":"1.6.3"},{"location":"developer/design/#164","text":"API key support is clear-text equivalent. Authentication via API key is probably not considered low risk secret. Keys can be disabled/revoked to mitigate breaches, but this is not a solution.","title":"1.6.4"},{"location":"developer/design/#171-172","text":"Audit log format is common and used when making calls via API. Stdout/stderr logging is not consistent. Audit logs are saved to table, not transmitted to a remote system. Stdout/stderr logging is not transmitted to a remote system,","title":"1.7.1, 1.7.2"},{"location":"developer/design/#181-182","text":"Sensitive data is not identified or classified into protection levels.","title":"1.8.1, 1.8.2"},{"location":"developer/design/#191-192","text":"Connection to database, other services must be encrypted.","title":"1.9.1, 1.9.2"},{"location":"developer/design/#1101","text":"Git and GitHub used for source code control, no formal commit procedure.","title":"1.10.1"},{"location":"developer/design/#1111","text":"Little documentation and definitions of application components, out of date.","title":"1.11.1"},{"location":"developer/design/#1112-1113","text":"No unsynchronised state shared between high-value business logic flows. All code should be threadsafe (no use of unsafe). I don't think there is any but probably needs more thorough check, including dependencies.","title":"1.11.2, 1.11.3"},{"location":"developer/design/#1121-1122","text":"No user uploaded files, if feature added in future files will be stored as binary blobs in database. Serve files as octet stream downloads if added.","title":"1.12.1, 1.12.2"},{"location":"developer/developer/","text":"Developer Docker images contain the development tools, build them with the command. source docker/alias.sh sso-build-update Create a network for containers. docker network create compose Development tools are run with the command. docker run --rm -it --init --user $(id -u):$(id -g) --network compose -v \"$(pwd):/build\" sso/build:v1 $ARGS Create an alias on Linux for the above with the command. alias sso-build='docker run --rm -it --init --user $(id -u):$(id -g) --network compose -v \"$(pwd):/build\" sso/build:v1' Development environment variables are configured in docker/build/build.dockerfile . Services are run using Docker Compose , start them with the command. sso build sso up Create an alias on Linux to run sso-build container with a hostname, this allows you to replace compose services during development without using host networking mode. sso-build-host() { local host=\"$1\" shift 1 docker run --rm -it --init --user $(id -u):$(id -g) --network compose -v \"$(pwd):/build\" --hostname $host --name $host sso/build:v1 \"$@\" } To use the sso-cli command you can access the sso-grpc container. docker exec -it sso_sso-grpc_1 /bin/bash sso-cli --help sso-cli create-root-key root sso-cli create-service-with-key test test.localhost --allow-register true --local-url test.localhost/auth/provider/local Stop and destroy services with the commands. sso stop sso down Create backup of sso database in postgres service. This backup will be restored automatically when the postgres service is rebuilt. docker exec sso_postgres_1 pg_dump -U guest --format=custom sso > docker/postgres/pgdump/sso.pgdump Reset database and create new PostgreSQL database migrations with Diesel . These commands expect postgres service is running. sso-build cargo make postgres-reset sso-build cargo make postgres-migration $migration_name Check source code using clippy . sso-build cargo make clippy Audit crate dependencies. sso-build cargo make audit Build libraries and binaries. sso-build cargo make build sso-build cargo make release Run development binaries. sso-build cargo make sso-cli -- $ARGS sso-build cargo make sso-grpc sso-build cargo make sso-openapi Run unit tests. sso-build cargo make test Run integration tests. This expects sso-grpc service is running and SSO_TEST_URL and SSO_TEST_KEY environment variables are defined. Where URL is the address of the gRPC server and key is a root key value returned by sso-cli . sso-build cargo make test-integration for i in {1..50}; do sso-build cargo make test-integration; done docker run --rm -it --init --network compose sso/build-release:v1 /bin/bash Compile Protocol Buffers for OpenAPI gateway server. sso-build cargo make protoc Build OpenAPI gateway server. sso-build cargo make openapi-bin This manual is written in Markdown and build into a static website using mkdocs . sso-mkdocs serve sso-mkdocs build Build crate documentation. sso-build cargo make doc Install crate locally. cargo install --force --path sso To publish crate(s) . Minikube Create a Minikube instance. minikube start --vm-driver=virtualbox minikube status minikube stop minikube delete minikube dashboard minikube ip (Re)build all Docker images and load images into Minikube. docker build --tag \"sso-build:\" . docker-compose build --parallel (cd kubernetes/minikube/docker && bash build.sh) Smallstep CA Create CA root certificate and certificate and key for server for testing, overwrite files in docker/build/cert . mkdir -p volumes/ca docker run --rm --user $(id -u):$(id -g) --network host -v \"$(pwd)/volumes/ca:/home/step\" -it smallstep/step-ca step ca init # STDIN: Localhost, localhost, :443, localhost, guest echo \"guest\" > volumes/ca/secrets/password docker run --rm --user $(id -u):$(id -g) --network host -v \"$(pwd)/volumes/ca:/home/step\" -it smallstep/step-ca /bin/bash step ca certificate --offline --not-after 999h --san traefik sso.localhost sso.crt sso.key step certificate inspect sso.crt # STDIN: guest Modify volumes/ca/config/ca.json . { \"authority\": { \"claims\": { \"maxTLSCertDuration\": \"999h\", \"defaultTLSCertDuration\": \"999h\" } } }","title":"Developer"},{"location":"developer/developer/#developer","text":"Docker images contain the development tools, build them with the command. source docker/alias.sh sso-build-update Create a network for containers. docker network create compose Development tools are run with the command. docker run --rm -it --init --user $(id -u):$(id -g) --network compose -v \"$(pwd):/build\" sso/build:v1 $ARGS Create an alias on Linux for the above with the command. alias sso-build='docker run --rm -it --init --user $(id -u):$(id -g) --network compose -v \"$(pwd):/build\" sso/build:v1' Development environment variables are configured in docker/build/build.dockerfile . Services are run using Docker Compose , start them with the command. sso build sso up Create an alias on Linux to run sso-build container with a hostname, this allows you to replace compose services during development without using host networking mode. sso-build-host() { local host=\"$1\" shift 1 docker run --rm -it --init --user $(id -u):$(id -g) --network compose -v \"$(pwd):/build\" --hostname $host --name $host sso/build:v1 \"$@\" } To use the sso-cli command you can access the sso-grpc container. docker exec -it sso_sso-grpc_1 /bin/bash sso-cli --help sso-cli create-root-key root sso-cli create-service-with-key test test.localhost --allow-register true --local-url test.localhost/auth/provider/local Stop and destroy services with the commands. sso stop sso down Create backup of sso database in postgres service. This backup will be restored automatically when the postgres service is rebuilt. docker exec sso_postgres_1 pg_dump -U guest --format=custom sso > docker/postgres/pgdump/sso.pgdump Reset database and create new PostgreSQL database migrations with Diesel . These commands expect postgres service is running. sso-build cargo make postgres-reset sso-build cargo make postgres-migration $migration_name Check source code using clippy . sso-build cargo make clippy Audit crate dependencies. sso-build cargo make audit Build libraries and binaries. sso-build cargo make build sso-build cargo make release Run development binaries. sso-build cargo make sso-cli -- $ARGS sso-build cargo make sso-grpc sso-build cargo make sso-openapi Run unit tests. sso-build cargo make test Run integration tests. This expects sso-grpc service is running and SSO_TEST_URL and SSO_TEST_KEY environment variables are defined. Where URL is the address of the gRPC server and key is a root key value returned by sso-cli . sso-build cargo make test-integration for i in {1..50}; do sso-build cargo make test-integration; done docker run --rm -it --init --network compose sso/build-release:v1 /bin/bash Compile Protocol Buffers for OpenAPI gateway server. sso-build cargo make protoc Build OpenAPI gateway server. sso-build cargo make openapi-bin This manual is written in Markdown and build into a static website using mkdocs . sso-mkdocs serve sso-mkdocs build Build crate documentation. sso-build cargo make doc Install crate locally. cargo install --force --path sso To publish crate(s) .","title":"Developer"},{"location":"developer/developer/#minikube","text":"Create a Minikube instance. minikube start --vm-driver=virtualbox minikube status minikube stop minikube delete minikube dashboard minikube ip (Re)build all Docker images and load images into Minikube. docker build --tag \"sso-build:\" . docker-compose build --parallel (cd kubernetes/minikube/docker && bash build.sh)","title":"Minikube"},{"location":"developer/developer/#smallstep-ca","text":"Create CA root certificate and certificate and key for server for testing, overwrite files in docker/build/cert . mkdir -p volumes/ca docker run --rm --user $(id -u):$(id -g) --network host -v \"$(pwd)/volumes/ca:/home/step\" -it smallstep/step-ca step ca init # STDIN: Localhost, localhost, :443, localhost, guest echo \"guest\" > volumes/ca/secrets/password docker run --rm --user $(id -u):$(id -g) --network host -v \"$(pwd)/volumes/ca:/home/step\" -it smallstep/step-ca /bin/bash step ca certificate --offline --not-after 999h --san traefik sso.localhost sso.crt sso.key step certificate inspect sso.crt # STDIN: guest Modify volumes/ca/config/ca.json . { \"authority\": { \"claims\": { \"maxTLSCertDuration\": \"999h\", \"defaultTLSCertDuration\": \"999h\" } } }","title":"Smallstep CA"},{"location":"developer/reference/","text":"","title":"Reference"},{"location":"guide/api-key/","text":"API Key Create service with key. sso-cli create-service-with-key $service_name $service_url Service creates a user without password. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"name\":\"$user_name\",\"email\":\"$user_email\"}' \\ sso.localhost/api/v1/user Service creates a key for user. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"type\":\"KEY\",\"name\":\"$key_name\",\"user_id\":\"$user_id\"}' \\ sso.localhost/api/v1/key User makes requests to service with key value, key can be verified to authenticate requests. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"key\":\"$user_key\"}' \\ sso.localhost/api/v1/auth/key/verify Key can be revoked, this will disable and revoke the key created earlier and prevent verification. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"key\":\"$user_key\"}' \\ sso.localhost/api/v1/auth/key/revoke","title":"API Key"},{"location":"guide/api-key/#api-key","text":"Create service with key. sso-cli create-service-with-key $service_name $service_url Service creates a user without password. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"name\":\"$user_name\",\"email\":\"$user_email\"}' \\ sso.localhost/api/v1/user Service creates a key for user. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"type\":\"KEY\",\"name\":\"$key_name\",\"user_id\":\"$user_id\"}' \\ sso.localhost/api/v1/key User makes requests to service with key value, key can be verified to authenticate requests. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"key\":\"$user_key\"}' \\ sso.localhost/api/v1/auth/key/verify Key can be revoked, this will disable and revoke the key created earlier and prevent verification. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"key\":\"$user_key\"}' \\ sso.localhost/api/v1/auth/key/revoke","title":"API Key"},{"location":"guide/cli/","text":"CLI","title":"CLI"},{"location":"guide/cli/#cli","text":"","title":"CLI"},{"location":"guide/csrf/","text":"CSRF Create service with key and start server. sso create-service-with-key $service_name $service_url sso start-server Service creates a CSRF token. curl --header \"Authorization: $service_key\" \\ $server_url/v1/auth/csrf Service verifies CSRF token. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"key\":\"$csrf_key\"}' \\ $server_url/v1/auth/csrf","title":"CSRF"},{"location":"guide/csrf/#csrf","text":"Create service with key and start server. sso create-service-with-key $service_name $service_url sso start-server Service creates a CSRF token. curl --header \"Authorization: $service_key\" \\ $server_url/v1/auth/csrf Service verifies CSRF token. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"key\":\"$csrf_key\"}' \\ $server_url/v1/auth/csrf","title":"CSRF"},{"location":"guide/deployment/","text":"Deployment Kubernetes Example Kubernetes configuration files can be found in the kubernetes directory of the repository. Prometheus Example Prometheus configuration and alerting rules can be found in the docker/prometheus directory of the repository. Traefik Example Traefik configuration files can be found in the docker/traefik directory of the repository. Can apply rate limit . Can use forward authentication with SSO_TRAEFIK environment variable. Can use router TLS or SSO_TLS_* environment variables for encrypting traffic. CORS CORS for sso-openapi binary can be configured using SSO_CORS_ALLOW_ORIGIN environment variable. If variable is undefined or empty string, defaults to allow all CORS requests (allow origin * and handle preflight requests). If variable is not empty, is treated as a comma separated list of acceptable origin values. If origin is undefined or empty request is not handled. If origin matches then allow origin header is et and preflight requests are handled.","title":"Deployment"},{"location":"guide/deployment/#deployment","text":"","title":"Deployment"},{"location":"guide/deployment/#kubernetes","text":"Example Kubernetes configuration files can be found in the kubernetes directory of the repository.","title":"Kubernetes"},{"location":"guide/deployment/#prometheus","text":"Example Prometheus configuration and alerting rules can be found in the docker/prometheus directory of the repository.","title":"Prometheus"},{"location":"guide/deployment/#traefik","text":"Example Traefik configuration files can be found in the docker/traefik directory of the repository. Can apply rate limit . Can use forward authentication with SSO_TRAEFIK environment variable. Can use router TLS or SSO_TLS_* environment variables for encrypting traffic.","title":"Traefik"},{"location":"guide/deployment/#cors","text":"CORS for sso-openapi binary can be configured using SSO_CORS_ALLOW_ORIGIN environment variable. If variable is undefined or empty string, defaults to allow all CORS requests (allow origin * and handle preflight requests). If variable is not empty, is treated as a comma separated list of acceptable origin values. If origin is undefined or empty request is not handled. If origin matches then allow origin header is et and preflight requests are handled.","title":"CORS"},{"location":"guide/login/","text":"Login Create service with key. sso-cli create-service-with-key $service_name $service_url \\ --local-url $service_local_url Service creates a user with password. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"name\":\"$user_name\",\"email\":\"$user_email\",\"locale\":\"en\",\"timezone\":\"Etc/UTC\",\"password_allow_reset\":true,\"password_require_update\":false,\"password\":\"$user_password\"}' \\ sso.localhost/api/v1/user Service creates a key for user. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"type\":\"TOKEN\",\"name\":\"$key_name\",\"user_id\":\"$user_id\"}' \\ sso.localhost/api/v1/key User makes login request to service, service makes a login request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"email\":\"$user_email\",\"password\":\"$user_password\"}' \\ sso.localhost/api/v1/auth/provider/local/login Service receives token response, access token can be verified to authenticate requests. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$access_token\"}' \\ sso.localhost/api/v1/auth/token/verify Refresh token can be used to refresh token. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$refresh_token\"}' \\ sso.localhost/api/v1/auth/token/refresh Access or refresh token can be revoked, this will disable the key created earlier and prevent verify and refresh. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$token\"}' \\ sso.localhost/api/v1/auth/token/revoke","title":"Login"},{"location":"guide/login/#login","text":"Create service with key. sso-cli create-service-with-key $service_name $service_url \\ --local-url $service_local_url Service creates a user with password. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"name\":\"$user_name\",\"email\":\"$user_email\",\"locale\":\"en\",\"timezone\":\"Etc/UTC\",\"password_allow_reset\":true,\"password_require_update\":false,\"password\":\"$user_password\"}' \\ sso.localhost/api/v1/user Service creates a key for user. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"type\":\"TOKEN\",\"name\":\"$key_name\",\"user_id\":\"$user_id\"}' \\ sso.localhost/api/v1/key User makes login request to service, service makes a login request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"email\":\"$user_email\",\"password\":\"$user_password\"}' \\ sso.localhost/api/v1/auth/provider/local/login Service receives token response, access token can be verified to authenticate requests. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$access_token\"}' \\ sso.localhost/api/v1/auth/token/verify Refresh token can be used to refresh token. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$refresh_token\"}' \\ sso.localhost/api/v1/auth/token/refresh Access or refresh token can be revoked, this will disable the key created earlier and prevent verify and refresh. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$token\"}' \\ sso.localhost/api/v1/auth/token/revoke","title":"Login"},{"location":"guide/oauth2-login/","text":"OAuth2 Login $server_url/v1/auth/provider/github/oauth2 Create service with OAuth2 provider URL and key, and start server. sso-cli create-service-with-key $service_name $service_url \\ [--github-oauth2-url $service_github_oauth2_url] \\ [--microsoft-oauth2-url $service_microsoft_oauth2_url] Service creates a user with email address matching OAuth2 provider. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"name\":\"$user_name\",\"email\":\"$user_email\",\"locale\":\"en\",\"timezone\":\"Etc/UTC\"}' \\ localhost:8042/v1/user Service creates a key for user. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"type\":\"TOKEN\",\"name\":\"$key_name\",\"user_id\":\"$user_id\"}' \\ localhost:8042/v1/key User makes OAuth2 login request to service, service requests a redirect URL for OAuth2 provider, supported providers are github , microsoft . curl --header \"Authorization: $service_key\" \\ localhost:8042/v1/auth/provider/$oauth2_provider/oauth2 Service redirects user to returned URL, OAuth2 provider authentication occurs. If successful, OAuth2 provider redirects user to $service_$provider_oauth2_url?code=$code&state=$state . Service receives query parameters for callback. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"code\":\"$code\",\"state\":\"$state\"}' \\ localhost:8042/v1/auth/provider/$oauth2_provider/oauth2 Query parameters are exchanged for API access token, authenticated email address is requested from OAuth2 provider APIs. If authenticated email returned by API matches a user email address, and user has key for specified service, a user token is produced and the user is redirected to $service_url?access_token=$token&refresh_token=$token . Service receives access token and refresh token via query parameters. Service can verify access token to authenticate requests. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$access_token\"}' \\ localhost:8042/v1/auth/token/verify Refresh token can be used to refresh token. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$refresh_token\"}' \\ localhost:8042/v1/auth/token/refresh Access or refresh token can be revoked. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$token\"}' \\ localhost:8042/v1/auth/token/revoke This will disable and revoke the user key created earlier.","title":"OAuth2 Login"},{"location":"guide/oauth2-login/#oauth2-login","text":"$server_url/v1/auth/provider/github/oauth2 Create service with OAuth2 provider URL and key, and start server. sso-cli create-service-with-key $service_name $service_url \\ [--github-oauth2-url $service_github_oauth2_url] \\ [--microsoft-oauth2-url $service_microsoft_oauth2_url] Service creates a user with email address matching OAuth2 provider. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"name\":\"$user_name\",\"email\":\"$user_email\",\"locale\":\"en\",\"timezone\":\"Etc/UTC\"}' \\ localhost:8042/v1/user Service creates a key for user. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"type\":\"TOKEN\",\"name\":\"$key_name\",\"user_id\":\"$user_id\"}' \\ localhost:8042/v1/key User makes OAuth2 login request to service, service requests a redirect URL for OAuth2 provider, supported providers are github , microsoft . curl --header \"Authorization: $service_key\" \\ localhost:8042/v1/auth/provider/$oauth2_provider/oauth2 Service redirects user to returned URL, OAuth2 provider authentication occurs. If successful, OAuth2 provider redirects user to $service_$provider_oauth2_url?code=$code&state=$state . Service receives query parameters for callback. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"code\":\"$code\",\"state\":\"$state\"}' \\ localhost:8042/v1/auth/provider/$oauth2_provider/oauth2 Query parameters are exchanged for API access token, authenticated email address is requested from OAuth2 provider APIs. If authenticated email returned by API matches a user email address, and user has key for specified service, a user token is produced and the user is redirected to $service_url?access_token=$token&refresh_token=$token . Service receives access token and refresh token via query parameters. Service can verify access token to authenticate requests. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$access_token\"}' \\ localhost:8042/v1/auth/token/verify Refresh token can be used to refresh token. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$refresh_token\"}' \\ localhost:8042/v1/auth/token/refresh Access or refresh token can be revoked. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$token\"}' \\ localhost:8042/v1/auth/token/revoke This will disable and revoke the user key created earlier.","title":"OAuth2 Login"},{"location":"guide/quickstart/","text":"Quickstart Install Docker and Docker Compose . Docker Desktop (Windows) Docker Engine (Ubuntu) Docker Compose Build Docker Compose service images and create network. export UID docker-compose -f docker/build.yml build docker-compose -f docker/sso.yml build docker network create compose Start services. docker-compose -f docker/sso.yml up If successful sso-grpc is now available at sso.localhost , and sso-openapi is available at sso.localhost/api . The following guides depend on the sso-cli command, it can be found in the sso_grpc container with the command. docker exec -it docker_sso-grpc_1 /bin/bash # root:/# sso-cli --help Docker services can be destroyed with the command. docker-compose -f docker/sso.yml down","title":"Quickstart"},{"location":"guide/quickstart/#quickstart","text":"Install Docker and Docker Compose . Docker Desktop (Windows) Docker Engine (Ubuntu) Docker Compose Build Docker Compose service images and create network. export UID docker-compose -f docker/build.yml build docker-compose -f docker/sso.yml build docker network create compose Start services. docker-compose -f docker/sso.yml up If successful sso-grpc is now available at sso.localhost , and sso-openapi is available at sso.localhost/api . The following guides depend on the sso-cli command, it can be found in the sso_grpc container with the command. docker exec -it docker_sso-grpc_1 /bin/bash # root:/# sso-cli --help Docker services can be destroyed with the command. docker-compose -f docker/sso.yml down","title":"Quickstart"},{"location":"guide/register/","text":"Register Create service with key and start server. sso create-service-with-key $service_name $service_url \\ --allow-register true \\ --email-text \"This is appended to outgoing emails.\" \\ --local-url $service_local_url sso start-server User makes a register request to service, service makes register request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"name\":\"$user_name\",\"email:\"$user_email\",\"locale\":\"en\",\"timezone\":\"Etc/UTC\"}' \\ $server_url/v1/auth/provider/local/register Email containing URL is sent to user email address, URL in format: $service_provider_local_url?type=register&email=$user_email&token=$token . Service receives token via query parameter and makes register confirm request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$token\",\"password\":\"$user_password\",\"password_allow_reset\":false}' \\ $server_url/v1/auth/provider/local/register/confirm User makes login request to service, service makes a login request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"email\":\"$user_email\",\"password\":\"$user_password\"}' \\ $server_url/v1/auth/provider/local/login","title":"Register"},{"location":"guide/register/#register","text":"Create service with key and start server. sso create-service-with-key $service_name $service_url \\ --allow-register true \\ --email-text \"This is appended to outgoing emails.\" \\ --local-url $service_local_url sso start-server User makes a register request to service, service makes register request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"name\":\"$user_name\",\"email:\"$user_email\",\"locale\":\"en\",\"timezone\":\"Etc/UTC\"}' \\ $server_url/v1/auth/provider/local/register Email containing URL is sent to user email address, URL in format: $service_provider_local_url?type=register&email=$user_email&token=$token . Service receives token via query parameter and makes register confirm request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$token\",\"password\":\"$user_password\",\"password_allow_reset\":false}' \\ $server_url/v1/auth/provider/local/register/confirm User makes login request to service, service makes a login request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"email\":\"$user_email\",\"password\":\"$user_password\"}' \\ $server_url/v1/auth/provider/local/login","title":"Register"},{"location":"guide/reset-password/","text":"Reset Password Create service with key. sso-cli create-service-with-key $service_name $service_url \\ --local-url $service_local_url Service creates a user with password. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"name\":\"$user_name\",\"email\":\"$user_email\",\"locale\":\"en\",\"timezone\":\"Etc/UTC\",\"password_allow_reset\":true,\"password_require_update\":false,\"password\":\"$user_password\"}' \\ localhost:8042/v1/user Service creates a key for user. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"type\":\"TOKEN\",\"name\":\"$key_name\",\"user_id\":\"$user_id\"}' \\ localhost:8042/v1/key User makes reset password request to service, service makes a reset password request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"email\":\"$user_email\"}' \\ localhost:8042/v1/auth/provider/local/reset-password Email containing password reset URL is sent to user email address, URL in format $service_provider_local_url?type=reset_password&email=$user_email&token=$token . Service receives token via query parameter and makes reset password confirm request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$token\",\"password\":\"$user_password\"}' \\ localhost:8042/v1/auth/provider/local/reset-password/confirm User makes login request to service, service makes a login request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"email\":\"$user_email\",\"password\":\"$user_password\"}' \\ localhost:8042/v1/auth/provider/local/login Email containing password reset revoke URL is sent to user email address, URL in format $service_provider_local_url?type=reset_password_confirm&email=$user_email&token=$token . Service receives token via query parameter and makes reset password revoke request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$token\"}' \\ localhost:8042/v1/auth/provider/local/reset-password/revoke This will disable the user, and disable and revoke all user keys.","title":"Reset Password"},{"location":"guide/reset-password/#reset-password","text":"Create service with key. sso-cli create-service-with-key $service_name $service_url \\ --local-url $service_local_url Service creates a user with password. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"name\":\"$user_name\",\"email\":\"$user_email\",\"locale\":\"en\",\"timezone\":\"Etc/UTC\",\"password_allow_reset\":true,\"password_require_update\":false,\"password\":\"$user_password\"}' \\ localhost:8042/v1/user Service creates a key for user. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"type\":\"TOKEN\",\"name\":\"$key_name\",\"user_id\":\"$user_id\"}' \\ localhost:8042/v1/key User makes reset password request to service, service makes a reset password request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"email\":\"$user_email\"}' \\ localhost:8042/v1/auth/provider/local/reset-password Email containing password reset URL is sent to user email address, URL in format $service_provider_local_url?type=reset_password&email=$user_email&token=$token . Service receives token via query parameter and makes reset password confirm request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$token\",\"password\":\"$user_password\"}' \\ localhost:8042/v1/auth/provider/local/reset-password/confirm User makes login request to service, service makes a login request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"email\":\"$user_email\",\"password\":\"$user_password\"}' \\ localhost:8042/v1/auth/provider/local/login Email containing password reset revoke URL is sent to user email address, URL in format $service_provider_local_url?type=reset_password_confirm&email=$user_email&token=$token . Service receives token via query parameter and makes reset password revoke request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$token\"}' \\ localhost:8042/v1/auth/provider/local/reset-password/revoke This will disable the user, and disable and revoke all user keys.","title":"Reset Password"},{"location":"guide/totp/","text":"TOTP Create service with key and start server. sso create-service-with-key $service_name $service_url sso start-server Service creates a user (password optional). curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"name\":\"$user_name\",\"email\":\"$user_email\",\"locale\":\"$user_locale\",\"timezone\":\"$user_timezone\"}' \\ $server_url/v1/user Service creates a TOTP key for user. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"allow_key\":false,\"allow_token\":false,\"allow_totp\":true,\"name\":\"$key_name\",\"user_id\":\"$user_id\"}' \\ $server_url/v1/key Generate QR code using the tool: https://freeotp.github.io/qrcode.html Issuer: sso Account: $user_email Secret: $user_key_value Digits: 6 SHA1 Timeout 30s Import the QR code into the application: https://freeotp.github.io/ User makes request to service with TOTP code, service verifies TOTP code. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"user_id\":\"$user_id\",\"totp\":\"$totp_code\"}' \\ $server_url/v1/auth/totp Key can be revoked, this will disable the key created earlier and prevent TOTP verification. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"key\":\"$user_key\"}' \\ $server_url/v1/auth/key/revoke","title":"TOTP"},{"location":"guide/totp/#totp","text":"Create service with key and start server. sso create-service-with-key $service_name $service_url sso start-server Service creates a user (password optional). curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"name\":\"$user_name\",\"email\":\"$user_email\",\"locale\":\"$user_locale\",\"timezone\":\"$user_timezone\"}' \\ $server_url/v1/user Service creates a TOTP key for user. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"allow_key\":false,\"allow_token\":false,\"allow_totp\":true,\"name\":\"$key_name\",\"user_id\":\"$user_id\"}' \\ $server_url/v1/key Generate QR code using the tool: https://freeotp.github.io/qrcode.html Issuer: sso Account: $user_email Secret: $user_key_value Digits: 6 SHA1 Timeout 30s Import the QR code into the application: https://freeotp.github.io/ User makes request to service with TOTP code, service verifies TOTP code. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"user_id\":\"$user_id\",\"totp\":\"$totp_code\"}' \\ $server_url/v1/auth/totp Key can be revoked, this will disable the key created earlier and prevent TOTP verification. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"key\":\"$user_key\"}' \\ $server_url/v1/auth/key/revoke","title":"TOTP"},{"location":"guide/update-email/","text":"Update Email Create service with key and start server. sso-cli create-service-with-key $service_name $service_url \\ --local-url $service_local_url Service creates a user with password. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"name\":\"$user_name\",\"email\":\"$user_email\",\"locale\":\"en\",\"timezone\":\"Etc/UTC\",\"password_allow_reset\":true,\"password_require_update\":false,\"password\":\"$user_password\"}' \\ localhost:8042/v1/user Service creates a key for user. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"type\":\"TOKEN\",\"name\":\"$key_name\",\"user_id\":\"$user_id\"}' \\ localhost:8042/v1/key User makes update email request to service, service makes an update email request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"email\":\"$user_email\",\"password\":\"$user_password\",\"new_email\":\"$new_user_email\"}' \\ localhost:8042/v1/auth/provider/local/update-email User makes login request to service, service makes a login request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"email\":\"$new_user_email\",\"password\":\"$user_password\"}' \\ localhost:8042/v1/auth/provider/local/login Email containing email update revoke URL is sent to old user email address, URL in format $service_provider_local_url?type=update_email&email=$user_email&old_email=$user_old_email&token=$token . Service receives token via query parameter and makes update email revoke request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$token\"}' \\ localhost:8042/v1/auth/provider/local/update-email/revoke This will disable the user, and disable and revoke all user keys.","title":"Update Email"},{"location":"guide/update-email/#update-email","text":"Create service with key and start server. sso-cli create-service-with-key $service_name $service_url \\ --local-url $service_local_url Service creates a user with password. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"name\":\"$user_name\",\"email\":\"$user_email\",\"locale\":\"en\",\"timezone\":\"Etc/UTC\",\"password_allow_reset\":true,\"password_require_update\":false,\"password\":\"$user_password\"}' \\ localhost:8042/v1/user Service creates a key for user. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"type\":\"TOKEN\",\"name\":\"$key_name\",\"user_id\":\"$user_id\"}' \\ localhost:8042/v1/key User makes update email request to service, service makes an update email request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"email\":\"$user_email\",\"password\":\"$user_password\",\"new_email\":\"$new_user_email\"}' \\ localhost:8042/v1/auth/provider/local/update-email User makes login request to service, service makes a login request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"email\":\"$new_user_email\",\"password\":\"$user_password\"}' \\ localhost:8042/v1/auth/provider/local/login Email containing email update revoke URL is sent to old user email address, URL in format $service_provider_local_url?type=update_email&email=$user_email&old_email=$user_old_email&token=$token . Service receives token via query parameter and makes update email revoke request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$token\"}' \\ localhost:8042/v1/auth/provider/local/update-email/revoke This will disable the user, and disable and revoke all user keys.","title":"Update Email"},{"location":"guide/update-password/","text":"Update Password Create service with key and start server. sso-cli create-service-with-key $service_name $service_url \\ --local-url $service_local_url Service creates a user with password. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"name\":\"$user_name\",\"email\":\"$user_email\",\"locale\":\"en\",\"timezone\":\"Etc/UTC\",\"password_allow_reset\":true,\"password_require_update\":false,\"password\":\"$user_password\"}' \\ localhost:8042/v1/user Service creates a key for user. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"type\":\"TOKEN\",\"name\":\"$key_name\",\"user_id\":\"$user_id\"}' \\ localhost:8042/v1/key User makes update password request to service, service makes an update password request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"email\":\"$user_email\",\"password\":\"$user_password\",\"new_password\":\"$new_user_password\"}' \\ localhost:8042/v1/auth/provider/local/update-password User makes login request to service, service makes a login request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"email\":\"$user_email\",\"password\":\"$new_user_password\"}' \\ localhost:8042/v1/auth/provider/local/login Email containing password update revoke URL is sent to user email address, URL in format $service_provider_local_url?type=update_password&email=$user_email&token=$token . Service receives token via query parameter and makes update password revoke request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$token\"}' \\ localhost:8042/v1/auth/provider/local/update-password/revoke This will disable the user, and disable and revoke all user keys.","title":"Update Password"},{"location":"guide/update-password/#update-password","text":"Create service with key and start server. sso-cli create-service-with-key $service_name $service_url \\ --local-url $service_local_url Service creates a user with password. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"name\":\"$user_name\",\"email\":\"$user_email\",\"locale\":\"en\",\"timezone\":\"Etc/UTC\",\"password_allow_reset\":true,\"password_require_update\":false,\"password\":\"$user_password\"}' \\ localhost:8042/v1/user Service creates a key for user. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"is_enabled\":true,\"type\":\"TOKEN\",\"name\":\"$key_name\",\"user_id\":\"$user_id\"}' \\ localhost:8042/v1/key User makes update password request to service, service makes an update password request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"email\":\"$user_email\",\"password\":\"$user_password\",\"new_password\":\"$new_user_password\"}' \\ localhost:8042/v1/auth/provider/local/update-password User makes login request to service, service makes a login request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"email\":\"$user_email\",\"password\":\"$new_user_password\"}' \\ localhost:8042/v1/auth/provider/local/login Email containing password update revoke URL is sent to user email address, URL in format $service_provider_local_url?type=update_password&email=$user_email&token=$token . Service receives token via query parameter and makes update password revoke request. curl --header \"Content-Type: application/json\" \\ --header \"Authorization: $service_key\" \\ --request POST \\ --data '{\"token\":\"$token\"}' \\ localhost:8042/v1/auth/provider/local/update-password/revoke This will disable the user, and disable and revoke all user keys.","title":"Update Password"}]}